// 来源： https://github.com/zq-david-wang/linux-tools/blob/main/ebpf/libbpf-bootstrap/openat.bpf.c
package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	"log"
	"os"
	"os/signal"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
)

// $BPF_CLANG and $BPF_CFLAGS are set by the Makefile.
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS bpf sys_enter_openat.c -- -I../../headers

func main() {
	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatal(err)
	}

	// Load pre-compiled programs and maps into the kernel.
	objs := bpfObjects{}
	if err := loadBpfObjects(&objs, nil); err != nil {
		log.Fatalf("loading objects: %v", err)
	}
	defer objs.Close()

	// Open a tracepoint and attach the pre-compiled program. Each time
	// the kernel function enters, the program will increment the execution
	// counter by 1.
	// The first two arguments are taken from the following pathname:
	// /sys/kernel/tracing/events/syscalls/sys_enter_openat
	kp, err := link.Tracepoint("syscalls", "sys_enter_openat", objs.TracepointOpenat, nil)
	if err != nil {
		log.Fatalf("opening tracepoint: %s", err)
	}
	defer kp.Close()

	log.Printf("Press Ctrl-C to exit and remove the program")
	log.Println("Waiting for events..")
	log.Printf("Successfully started! Please run \"sudo cat /sys/kernel/debug/tracing/trace_pipe\" to see output of the BPF programs\n")

	stopper := make(chan os.Signal, 1)
	signal.Notify(stopper, os.Interrupt)

	// Open a ringbuf reader from userspace RINGBUF map described in the eBPF C program.
	rd, err := ringbuf.NewReader(objs.Events)
	if err != nil {
		log.Fatalf("opening ringbuf reader: %s", err)
	}
	defer rd.Close()

	// Close the reader when the process receives a signal, which will exit
	// the read loop.
	go func() {
		<-stopper

		if err := rd.Close(); err != nil {
			log.Fatalf("closing ringbuf reader: %s", err)
		}
	}()

	log.Println("Waiting for events..")

	// bpfEvent is generated by bpf2go.
	var cd cdata
	for {
		record, err := rd.Read()
		if err != nil {
			if errors.Is(err, ringbuf.ErrClosed) {
				log.Println("Received signal, exiting..")
				return
			}
			log.Printf("reading from reader: %s", err)
			continue
		}

		// Parse the ringbuf event entry into a bpfEvent structure.
		if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &cd); err != nil {
			log.Printf("parsing ringbuf event: %s", err)
			continue
		}

		log.Printf(`
CgroupId: %d HostTid: %d HostPid: %d HostPpid: %d
Tid: %d Pid: %d Ppid: %d Uid: %d Gid: %d
CgroupNsId: %d IpcNsId: %d NetNsId: %d MountNsId: %d PidNsId: %d TimeNsId: %d UserNsId: %d UtsNsId: %d
Comm: %s

`,
			cd.CgroupId, cd.HostTid, cd.HostPid, cd.HostPpid,
			cd.Tid, cd.Pid, cd.Ppid, cd.Uid, cd.Gid,
			cd.CgroupNsId, cd.IpcNsId, cd.NetNsId, cd.NetNsId, cd.MountNsId, cd.TimeNsId, cd.UserNsId, cd.UtsNsId,
			cd.commName())
	}
}

type cdata struct {
	CgroupId uint64
	HostTid  uint32
	HostPid  uint32
	HostPpid uint32

	Tid  uint32
	Pid  uint32
	Ppid uint32
	Uid  uint32
	Gid  uint32

	CgroupNsId uint32
	IpcNsId    uint32
	NetNsId    uint32
	MountNsId  uint32
	PidNsId    uint32
	TimeNsId   uint32
	UserNsId   uint32
	UtsNsId    uint32

	Comm [16]byte
}

func (c cdata) commName() string {
	return string(bytes.TrimRight(c.Comm[:], "\x00"))
}
