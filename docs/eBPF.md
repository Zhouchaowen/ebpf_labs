# What is eBPF?

eBPF（扩展伯克利数据包过滤器）是一项源自Linux内核的革命性技术，它可以在特权上下文中运行沙盒化的程序，例如操作系统内核。它用于在不需要更改内核源代码或加载内核模块的情况下，安全且高效地扩展内核的功能。

从历史上看，由于内核具有监控和控制整个系统的特权能力，操作系统一直是实施可观测性、安全性和网络功能的理想场所。与此同时，由于内核在系统中的核心角色以及对稳定性和安全性的高要求，操作系统内核的演进难度较大。因此，与在操作系统外部实施的功能相比，操作系统级别的创新速度传统上较低。

[]

eBPF从根本上改变了这一公式。它允许沙盒化的程序在操作系统内运行，这意味着应用程序开发者可以在运行时运行eBPF程序，以向操作系统添加额外的功能。操作系统然后通过即时编译器（Just-In-Time，JIT）和验证引擎的帮助来保证安全性和执行效率，就像本地编译一样。这引发了一系列基于eBPF的项目，涵盖了广泛的用例，包括下一代网络、可观测性和安全功能。

今天，eBPF被广泛用于推动各种各样的用例：在现代数据中心和云原生环境中提供高性能的网络和负载平衡、以低开销提取细粒度的安全可观测性数据、帮助应用程序开发者跟踪应用程序、提供性能故障排除的见解、预防性的应用程序和容器运行时安全强制执行，等等。可能性是无限的，eBPF正在释放的创新才刚刚开始。

BPF最初代表伯克利数据包过滤器（Berkeley Packet Filter），但现在随着eBPF（扩展BPF）可以执行远超数据包过滤的功能，这个缩写已经不再合适。eBPF现在被认为是一个独立的术语，没有特定的缩写含义。在Linux源代码中，术语BPF仍然存在，而在工具和文档中，通常可以互换使用BPF和eBPF这两个术语。原始的BPF有时被称为cBPF（经典BPF），以区别于eBPF。

# Introduction to eBPF

## Hook Overview

eBPF程序是事件驱动的，并在内核或应用程序通过特定的挂钩点时运行。预定义的挂钩点包括系统调用、函数入口/出口、内核跟踪点、网络事件以及其他几种情况。

[]

如果对于特定需求不存在预定义的挂钩点，那么可以创建内核探测点（kprobe）或用户空间探测点（uprobe），以便将eBPF程序附加到内核或用户应用程序的几乎任何位置。这样可以实现更灵活的功能扩展。

[]



## How are eBPF programs written?

在许多情况下，eBPF并不直接使用，而是通过项目如Cilium、bcc或bpftrace间接使用。这些项目在eBPF之上提供了一层抽象，不需要直接编写程序，而是提供了指定基于意图的定义的能力，然后使用eBPF来实现这些定义。这种方式使得使用eBPF更加方便，特别是在复杂的场景中，可以更容易地利用eBPF的强大功能来解决问题。

[]

如果没有更高级的抽象存在，就需要直接编写eBPF程序。Linux内核期望eBPF程序以字节码的形式加载。虽然当然可以直接编写字节码，但更常见的开发实践是利用编译套件，如LLVM，将伪C代码编译成eBPF字节码。这种方法更容易理解和维护，并且提供了更高的可读性和可维护性。它使开发者能够使用熟悉的C语言语法来编写eBPF程序，然后将其转换为可在内核中执行的字节码。

## Loader & Verification Architecture

当确定所需的挂钩点后，可以使用bpf系统调用将eBPF程序加载到Linux内核中。通常情况下，可以使用现有的eBPF库之一来完成这个操作。接下来的部分将介绍可用的开发工具链。

[]

当程序加载到Linux内核中时，在附加到请求的挂钩点之前，它会经过两个步骤：

## Verification

验证步骤确保eBPF程序可以安全运行。它验证程序是否满足多个条件，例如：

[]

- 加载eBPF程序的进程具有所需的权限（特权）。除非启用非特权eBPF，否则只有特权进程才能加载eBPF程序。
- 程序不会崩溃或以其他方式损害系统。
- 程序始终运行到完成（即程序不会永远陷入循环，阻止进一步处理）。

## JIT Compilation

即时编译（JIT）编译步骤将程序的通用字节码翻译成特定于机器的指令集，以优化程序的执行速度。这使得eBPF程序能够以与本地编译的内核代码或加载为内核模块的代码一样的高效方式运行。这是为了确保eBPF程序在执行时能够获得尽可能高的性能。

## Maps

eBPF程序的一个重要方面是能够共享收集的信息并存储状态。为此，eBPF程序可以利用eBPF映射的概念，以在各种数据结构中存储和检索数据。eBPF映射可以从eBPF程序以及通过系统调用从用户空间应用程序中访问。这使得eBPF程序能够有效地与用户空间应用程序交互并共享数据，从而扩展了其功能和灵活性。

[]

以下是一个不完整的支持的映射类型列表，以帮助理解数据结构的多样性。对于各种映射类型，都有共享和每个CPU变体可用。

- 哈希表（Hash tables）
- 数组（Arrays）
- LRU（最近最少使用）
- 环形缓冲区（Ring Buffer）
- 堆栈跟踪（Stack Trace）
- LPM（最长前缀匹配，Longest Prefix Match）

这些不同类型的eBPF映射允许eBPF程序以高效的方式管理和存储各种类型的数据，从而增强了其适用性和能力。

## Helper Calls

eBPF程序不能调用任意内核函数。允许这样做将会将eBPF程序与特定的内核版本绑定在一起，从而复杂化了程序的兼容性。相反，eBPF程序可以调用助手函数（helper functions），这是内核提供的一个众所周知且稳定的API。这种方式确保了eBPF程序与不同内核版本的兼容性，并提供了一种可靠的方法来执行与内核相关的操作。这些助手函数提供了一组受限制的功能，可以在eBPF程序中使用，以便执行各种任务，同时保持了稳定性和可移植性。

[]

可用的助手调用集合不断发展。一些可用的助手调用示例包括：

- 生成随机数
- 获取当前时间和日期
- eBPF映射访问
- 获取进程/控制组上下文
- 操纵网络数据包和转发逻辑

## Tail & Function Calls

eBPF程序具有可组合性，具备尾调用（tail call）和函数调用（function call）的概念。函数调用允许在eBPF程序内定义和调用函数。尾调用可以调用和执行另一个eBPF程序，并替换执行上下文，类似于常规进程的execve()系统调用的操作方式。

[]

## eBPF Safety

众所周知，伴随着巨大的能力也必然伴随着巨大的责任。

eBPF是一项极其强大的技术，现在运行在许多关键的软件基础设施组件的核心位置。在eBPF开发过程中，eBPF的安全性是考虑将其纳入Linux内核时最重要的方面之一。eBPF的安全性通过多个层面来确保：

## Required Privileges

除非启用非特权eBPF，所有希望将eBPF程序加载到Linux内核的进程必须在特权模式（root）下运行或需要具有CAP_BPF权限。这意味着不受信任的程序无法加载eBPF程序。

如果启用了非特权eBPF，非特权进程可以加载某些eBPF程序，但功能集会受到限制，并且对内核的访问受到限制。

## Verifier

如果允许一个进程加载eBPF程序，那么所有程序都必须通过eBPF验证器。eBPF验证器确保了程序本身的安全性。这意味着，例如：

- 程序被验证以确保它们始终运行到完成，例如，eBPF程序绝不能阻塞或永远陷入循环。eBPF程序可以包含所谓的有界循环，但只有在验证器可以确保循环包含一个保证变为真的退出条件时，程序才会被接受。
- 程序不得使用任何未初始化的变量或访问超出边界的内存。
- 程序必须符合系统的大小要求。无法加载任意大的eBPF程序。
- 程序必须具有有限的复杂性。验证器将评估所有可能的执行路径，并必须能够在配置的上限复杂性限制内完成分析。 验证器旨在作为安全工具，检查程序是否安全运行。它不是一个检查程序正在执行什么操作的安全工具。

## Hardening

在验证成功完成后，根据程序是从特权或非特权进程加载，eBPF程序经历了一系列强化过程。这一步包括：

- 程序执行保护：包含eBPF程序的内核内存受到保护，并被设置为只读。如果由于任何原因，无论是内核漏洞还是恶意篡改，eBPF程序被尝试修改，内核将崩溃，而不是允许其继续执行已损坏/篡改的程序。
- 防范Spectre漏洞：在推测执行期间，CPU可能会误判分支并留下可观察的副作用，这些副作用可以通过侧信道提取出来。为举例说明，eBPF程序会掩盖内存访问，以便在瞬时指令下重定向访问到受控区域，验证器还会跟踪仅在推测执行下可访问的程序路径，而JIT编译器则在尾调用无法转换为直接调用时发出Retpolines。
- 常量混淆：代码中的所有常量都会混淆，以防止JIT spraying攻击。这可以防止攻击者将可执行代码注入为常量，而在存在其他内核漏洞的情况下，可能允许攻击者跳转到eBPF程序的内存部分以执行代码。

## Abstracted Runtime Context

eBPF程序不能直接访问任意内核内存。超出程序上下文的数据和数据结构必须通过eBPF助手函数来访问。这确保了一致的数据访问，并使得任何此类访问受制于eBPF程序的权限，例如，只有与程序类型相关的数据结构才能被读取或（有时）修改，前提是验证器在加载时可以确保不会发生越界访问；或者只有在可以保证修改是安全的情况下，eBPF程序运行时才允许修改某些数据结构的数据。eBPF程序无法随意修改内核中的数据结构。这确保了内核的稳定性和安全性。

# Development Toolchains

## bcc

## bpftrace

## eBPF Go Library

eBPF Go库提供了一个通用的eBPF库，将获取eBPF字节码的过程与eBPF程序的加载和管理分离开来。通常，eBPF程序是通过编写高级语言来创建的，然后使用clang/LLVM编译器将其编译成eBPF字节码。这个库的目标是简化eBPF程序的开发和管理，使开发者能够更轻松地利用eBPF技术来扩展内核和实现各种用例。